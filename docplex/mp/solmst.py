# --------------------------------------------------------------------------
# Source file provided under Apache License, Version 2.0, January 2004,
# http://www.apache.org/licenses/
# (c) Copyright IBM Corp. 2015, 2016
# ----------------------------------

# gendoc: ignore

import sys

from docplex.mp.compat23 import StringIO
from docplex.mp.utils import is_iterable, OutputStreamAdapter
from docplex.mp.format import LPFormat

class SolutionMSTPrinter(object):
    # header contains the final newline
    mst_header = """<?xml version = "1.0" standalone="yes"?>
"""
    mst_extension = ".mst"

    one_solution_start_tag = "<CPLEXSolution version=\"1.0\">"
    one_solution_end_tag = "</CPLEXSolution>"

    # used when several solutions are present
    many_solution_start_tag = "<CPLEXSolutions version=\"1.0\">"
    many_solution_end_tag = "</CPLEXSolutions>"

    print_generated_vars = False

    @staticmethod
    def print_signature(out):
        from docplex.version import docplex_version_string
        osa = OutputStreamAdapter(out)
        osa.write("<!-- This file has been generated by DOcplex version {}  -->\n".format(docplex_version_string))

    @classmethod
    def _print_to_stream2(cls, out, solutions):
        # solutions can be either a plain solution or a sequence or an iterator
        if not is_iterable(solutions):
            cls.print_one_solution(solutions, out)
        else:
            sol_seq = list(solutions)
            nb_solutions = len(sol_seq)
            assert nb_solutions > 0
            if 1 == nb_solutions:
                cls.print_one_solution(sol_seq[0], out)
            else:
                cls.print_many_solutions(sol_seq, out)

    @classmethod
    def print_one_solution(cls, sol, out, print_header=True):
        osa = OutputStreamAdapter(out)
        if print_header:
            osa.write(cls.mst_header)
            cls.print_signature(out)
        # <CPLEXSolution version="1.0">
        osa.write(cls.one_solution_start_tag)
        osa.write("\n")

        # <header
        # problemName="foo"
        # objectiveValue="42"
        # />
        osa.write(" <header\n   problemName=\"{0}\"\n".format(sol.problem_name))
        if sol.has_objective():
            osa.write("   objectiveValue=\"{0:g}\"\n".format(sol.objective_value))
        osa.write("  />\n")

        # prepare reduced costs
        """ For mst, we don't want this !
        model = sol.model
        if not model._solves_as_mip():
            reduced_costs = model.reduced_costs(model.iter_variables())
        else:
            reduced_costs = []
        """
        #  <variables>
        #    <variable name="x1" index ="1" value="3.14"/>
        #  </variables>
        osa.write(" <variables>\n")
        """ For mst, we don't want this !
        for (dvar, rc) in zip_longest(model.iter_variables(), reduced_costs,
                                      fillvalue=None):
            var_name = dvar.name
            var_value = sol[dvar]
            var_index = dvar.index
            rc_string = ""
            if rc is not None:
                rc_string = "reducedCost=\"{}\"".format(rc)
            osa.write("  <variable name=\"{0}\" index=\"{1}\" value=\"{2:g}\" {3}/>\n"
              .format(var_name, var_index, var_value, rc_string))
        """
        print_generated = cls.print_generated_vars
        for dvar, _ in sol.iter_var_values():
            if print_generated or not dvar.is_generated():
                var_name = cls.var_mst_name(dvar)
                var_value = sol[dvar]
                var_index = dvar.index
                osa.write("  <variable name=\"{0}\" index=\"{1}\" value=\"{2:g}\"/>\n"
                          .format(var_name, var_index, var_value))
        osa.write(" </variables>\n")

        #  </CPLEXSolution version="1.0">
        osa.write(cls.one_solution_end_tag)
        osa.write("\n")

    @classmethod
    def var_mst_name(cls, dvar):
        return LPFormat.lp_var_name(dvar)

    @classmethod
    def print_many_solutions(cls, sol_seq, out):
        osa = OutputStreamAdapter(out)
        osa.write(cls.mst_header)
        cls.print_signature(out)
        # <CPLEXSolutions version="1.0">
        osa.write(cls.many_solution_start_tag)
        osa.write("\n")

        for sol in sol_seq:
            cls.print_one_solution(sol, out, print_header=False)

        # <CPLEXSolutions version="1.0">
        osa.write(cls.many_solution_end_tag)
        osa.write("\n")

    @classmethod
    def print_to_stream(cls, solutions, out, extension=mst_extension, **kwargs):
        if out is None:
            # prints on standard output
            cls._print_to_stream2(sys.stdout, solutions)
        elif isinstance(out, str):
            # a string is interpreted as a path name
            path = out if out.endswith(extension) else out + extension
            with open(path, "w") as of:
                cls.print_to_stream(solutions, of)
                # print("* file: %s overwritten" % path)
        else:
            try:
                cls._print_to_stream2(out, solutions)

            except AttributeError:  # pragma: no cover
                pass  # pragma: no cover
                # stringio will raise an attribute error here, due to with
                # print("Cannot use this an output: %s" % str(out))

    @classmethod
    def print_to_string(cls, solutions):
        oss = StringIO()
        cls.print_to_stream(solutions, out=oss)
        return oss.getvalue()
